# Fits Cumulative Prospect Theory
# Data from Rieskamp (cur_n simulated paritipants, 60 gamble-pairs with mixed outcomes)
data
{
  ### Generate II as the identity matrix and zeros as a vector of zeros
  for (l in 1:5) {
    zeros[l] <- 0
   for (ll in 1:5) {
    II[l,ll] <- ifelse(l==ll, 1,0)
   }
  }
  

}

model
{


# The model assumes that every participant has a unique parameter-value 
# on each of the six parameters of hierarchical-CPT (see, Nilsson, Rieskamp, & Wagnemakers, 2010).
# Furthermore, it assumes that the individual values on parameter-dimension X 
# are sampled from the hyperdistribution for X. This has to be defined in the model code.

  
  #### Population distribution priors
  for (k in 1:5) {
    mu.trans.pars[k] ~ dnorm(0,1)
  }
  InvSig.trans.pars  ~ dwish(II[1:5,1:5],6)
  
  ####
  Sig.trans.pars[1:5,1:5] <- inverse(InvSig.trans.pars[1:5,1:5])  
  
  
  # Define the correct and incorrect actual parameter means
  mu.alpha <- 2*phi(mu.trans.pars[1]) 
  mu.gamma <- 2*phi(mu.trans.pars[2]) 
  mu.delta <- 2*phi(mu.trans.pars[3]) 
  mu.lambda<-   exp(mu.trans.pars[4])
  mu.luce  <-   exp(mu.trans.pars[5])
  
  mu.alpha_sebi <- 2*phi(mu.trans.pars[1] / sqrt(1+ pow(Sig.trans.pars[1,1], 2))) 
  mu.gamma_sebi <- 2*phi(mu.trans.pars[2] / sqrt(1+ pow(Sig.trans.pars[2,2], 2)))
  mu.delta_sebi <- 2*phi(mu.trans.pars[3] / sqrt(1+ pow(Sig.trans.pars[3,3], 2))) 
  mu.luce_sebi  <-   exp(mu.trans.pars[4] + pow(Sig.trans.pars[4,4], 2)/2)
  mu.lambda_sebi<-   exp(mu.trans.pars[5] + pow(Sig.trans.pars[5,5], 2)/2)
  
  
  
  
  
	## Participant distributions
	for (j in 1:cur_n)
	{
    ## Sample random effects of participants from multi-variate normal
	  randeff[j,1:5]  ~ dmnorm(zeros, InvSig.trans.pars)
	  ## Compute transformed participant-parameters
	  sbj.trans.pars[j, 1:5] <- mu.trans.pars + randeff[j, 1:5]
	  
	  # Transform individual parameters to parameter-scale
	  alpha[j] <- 2*phi(sbj.trans.pars[j, 1])
		gamma[j] <- 2*phi(sbj.trans.pars[j, 2])
		delta[j] <- 2*phi(sbj.trans.pars[j, 3])
		luce[j]  <-   exp(sbj.trans.pars[j, 4]) 
    lambda[j] <-  exp(sbj.trans.pars[j, 5])
    
    ## Choice-loops:
    
    
# It is now time to define how the model should be fit to data. 

			for (i in 1:60)# Item-Loop, mixed gambles,gamble A
   		{
     			v.x.a[i,j] <- pow(mixed_prospects.a[i,3],alpha[j])       
      			v.y.a[i,j] <- (-1 * lambda[j]) * pow((-1 * mixed_prospects.a[i,1]),alpha[j])       

     			w.x.a[i,j] <- pow(mixed_prospects.a[i,4],gamma[j]) / pow(z.a[i,j],(1/gamma[j])) 
      			w.y.a[i,j] <- pow(mixed_prospects.a[i,2],delta[j]) / pow(z.a[i,j],(1/delta[j])) 
      			z.a[i,j]   <- pow(mixed_prospects.a[i,4],gamma[j]) + pow(mixed_prospects.a[i,2],delta[j]) 

      			Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}

   		for (i in 1:60)# Item-Loop, mixed gambles,gamble B
   		{
      			v.x.b[i,j] <- pow(mixed_prospects.b[i,3],alpha[j])       
      			v.y.b[i,j] <- (-1 * lambda[j]) * pow((-1 * mixed_prospects.b[i,1]),alpha[j])       

      			w.x.b[i,j] <- pow(mixed_prospects.b[i,4],gamma[j]) / pow(z.b[i,j],(1/gamma[j])) 
      			w.y.b[i,j] <- pow(mixed_prospects.b[i,2],delta[j]) / pow(z.b[i,j],(1/delta[j])) 
      			z.b[i,j]   <- pow(mixed_prospects.b[i,4],gamma[j]) + pow(mixed_prospects.b[i,2],delta[j]) 

      			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 1:60)# Item-Loop, mixed gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*luce[j])*(Vf.b[i,j]-Vf.a[i,j])))
			Data[i,j] ~ dbern(binval[i,j])
   		}
 	}   
}