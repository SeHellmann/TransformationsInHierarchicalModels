# Fits Cumulative Prospect Theory
# Data from Rieskamp (30 paritipants, 60 gamble-pairs 
# with positive outcomes, 60 gamble-pairs with negative
# outcomes, and 60 gamble-pairs with mixed outcomes)


model
{


# The model assumes that every participant has a unique parameter-value 
# on each of the six parameters of hierarchical-CPT (see, Nilsson, Rieskamp, & Wagnemakers, 2010).
# Furthermore, it assumes that the individual values on parameter-dimension X 
# are sampled from the hyperdistribution for X. This has to be defined in the model code.

	
	for (j in 1:30)
	{

		# We start by defining that participant j has a unique parameter-value 
		# on each of the six parameters: alpha, beta, gamma.gain, gamma.loss, lambda, and sens 
		# (the choice-rule parameter).
		# Note that the parameter 'sens' is used in the logit choice rule below.  
		# phi() is the cumulative distribution of the standard normal distribution (inverse probit)

		alpha[j] <- phi(alpha.phi[j])
		beta[j] <- phi(beta.phi[j])
		gamma.gain[j] <- phi(gamma.gain.phi[j])
		gamma.loss[j] <- phi(gamma.loss.phi[j])	
		sens[j]   <- exp(lsens[j]) 
    lambda[j] <- exp(llambda[j])
		
		# We put group-level normals on the individual parameters:
		alpha.phi[j] ~ dnorm(mu.phi.alpha,tau.phi.alpha)
		beta.phi[j] ~ dnorm(mu.phi.beta,tau.phi.beta)
		gamma.gain.phi[j] ~ dnorm(mu.phi.gamma.gain,tau.phi.gamma.gain)
		gamma.loss.phi[j] ~ dnorm(mu.phi.gamma.loss,tau.phi.gamma.loss)
  	lsens[j]   ~ dnorm(lmu.sens, ltau.sens)
  	llambda[j] ~ dnorm(lmu.lambda, ltau.lambda)
		
	}


	# Here priors for the hyperdistributions are defined:
	mu.phi.alpha ~ dnorm(0,1)
	tau.phi.alpha <- pow(sigma.phi.alpha,-2)
	sigma.phi.alpha ~ dunif(0,10)

	mu.phi.beta ~ dnorm(0,1)
	tau.phi.beta <- pow(sigma.phi.beta,-2)
	sigma.phi.beta ~ dunif(0,10)

	mu.phi.gamma.gain ~ dnorm(0,1)
	tau.phi.gamma.gain <- pow(sigma.phi.gamma.gain,-2)
	sigma.phi.gamma.gain ~ dunif(0,10)

	mu.phi.gamma.loss ~ dnorm(0,1)
	tau.phi.gamma.loss <- pow(sigma.phi.gamma.loss,-2)
	sigma.phi.gamma.loss ~ dunif(0,10)
	
	lmu.lambda    ~ dunif(-2.3, 1.61) 
	ltau.lambda  <- pow(lsigma.lambda,-2)
	lsigma.lambda ~ dunif(0,1.13)
	lmu.sens    ~ dunif(-2.3, 1.61)   
	ltau.sens  <- pow(lsigma.sens,-2)
	lsigma.sens ~ dunif(0,1.13)       

	
	# To obtain the mean of the hyper distribution on the wanted scale:
	mu.alpha <- phi(mu.phi.alpha) 
	mu.beta <- phi(mu.phi.beta)
	mu.gamma.gain <- phi(mu.phi.gamma.gain) 
	mu.gamma.loss <- phi(mu.phi.gamma.loss) 
	mu.lambda <- exp(lmu.lambda)
	mu.sens   <- exp(lmu.sens)
	
	mu.alpha_sebi <-  phi(mu.phi.alpha / sqrt(1+ pow(sigma.phi.alpha, 2))) 
	mu.beta_sebi <-  phi(mu.phi.beta / sqrt(1+ pow(sigma.phi.beta, 2))) 
	mu.gamma.gain_sebi <- phi(mu.phi.gamma.gain / sqrt(1+ pow(sigma.phi.gamma.gain, 2)))
  mu.gamma.loss_sebi <- phi(mu.phi.gamma.loss / sqrt(1+ pow(sigma.phi.gamma.loss, 2))) 
  mu.sens_sebi   <- exp(lmu.sens + pow(lsigma.sens, 2)/2)
  mu.lambda_sebi   <- exp(lmu.lambda + pow(lsigma.lambda, 2)/2)
  


# It is now time to define how the model should be fit to data. 

	for (j in 1:30)# Subject-loop
	{
	
   		for (i in 1:60)# Item-Loop, positive gambles,gamble A
   		{

# j:s subjective value of outcome 1 in gamble A of gamble-pair i, v.x.a[i,j], equals:

     			v.x.a[i,j] <- pow(prospects.a[i,1],alpha[j])

# where prospects.a[i,1] = outcome 1 and alpha[j] = j:s value on the alpha parameter
# j:s subjective value of outcome 2 in gamble A
       
      			v.y.a[i,j] <- pow(prospects.a[i,3],alpha[j])       

# j:s subjective probability of the relatively more positive outcomes w.y.a[i,j]

     			
      			w.y.a[i,j] <- pow(prospects.a[i,4],gamma.gain[j]) / pow(z.a[i,j],(1/gamma.gain[j])) 
      			z.a[i,j]   <- pow(prospects.a[i,2],gamma.gain[j]) + pow(prospects.a[i,4],gamma.gain[j]) 

# j:s subjective value of gamble A in gamble-pair i

      			Vf.a[i,j]  <- (1 - w.y.a[i,j]) * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}


   		for (i in 1:60)# Item-Loop, positive gambles,gamble B
   		{
      			v.x.b[i,j] <- pow(prospects.b[i,1],alpha[j])       
      			v.y.b[i,j] <- pow(prospects.b[i,3],alpha[j])       

      			 
      			w.y.b[i,j] <- pow(prospects.b[i,4],gamma.gain[j]) / pow(z.b[i,j],(1/gamma.gain[j])) 
      			z.b[i,j]   <- pow(prospects.b[i,2],gamma.gain[j]) + pow(prospects.b[i,4],gamma.gain[j]) 

      			Vf.b[i,j]  <- (1 - w.y.b[i,j]) * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 1:60)# Item-Loop, positive gambles,choice-rule
   		{

# It is defined that j:s choice for gamble-pair i is sampled from a Bernoulli-distribution 
# with p = binval[i,j].
# The logit choice-rule is used to compute binval[i,j] 
# (in this case: binval[i,j] = probability of B-choice).
      
			binval[i,j] <- (1)/(1+exp((-1*sens[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


		
   		for (i in 61:120)# Item-Loop, negative gambles,gamble A
   		{
     			v.x.a[i,j] <- (-1) * pow((-1 * prospects.a[i,1]),beta[j])       
      			v.y.a[i,j] <- (-1) * pow((-1 * prospects.a[i,3]),beta[j])       

     			w.x.a[i,j] <- pow(prospects.a[i,2],gamma.loss[j]) / pow(z.a[i,j],(1/gamma.loss[j])) 
     
      			z.a[i,j]   <- pow(prospects.a[i,2],gamma.loss[j]) + pow(prospects.a[i,4],gamma.loss[j]) 

      			Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + (1 - w.x.a[i,j]) * v.y.a[i,j]
      
   		}

   		for (i in 61:120)# Item-Loop, negative gambles,gamble B
   		{
      			v.x.b[i,j] <- (-1) * pow((-1 * prospects.b[i,1]),beta[j])       
      			v.y.b[i,j] <- (-1) * pow((-1 * prospects.b[i,3]),beta[j])       

      			w.x.b[i,j] <- pow(prospects.b[i,2],gamma.loss[j]) / pow(z.b[i,j],(1/gamma.loss[j])) 
      			
      			z.b[i,j]   <- pow(prospects.b[i,2],gamma.loss[j]) + pow(prospects.b[i,4],gamma.loss[j]) 

      			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + (1 - w.x.b[i,j]) * v.y.b[i,j]
      
   		}
 
   		for (i in 61:120)# Item-Loop, negative gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*sens[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


		for (i in 121:180)# Item-Loop, mixed gambles,gamble A
   		{
     			v.x.a[i,j] <- pow(prospects.a[i,3],alpha[j])       
      		v.y.a[i,j] <- (-1 * lambda[j]) * pow((-1 * prospects.a[i,1]),beta[j])       

     			w.x.a[i,j] <- pow(prospects.a[i,4],gamma.gain[j]) / pow(z.x.a[i,j],(1/gamma.gain[j])) 
      		w.y.a[i,j] <- pow(prospects.a[i,2],gamma.loss[j]) / pow(z.y.a[i,j],(1/gamma.loss[j])) 
      		z.x.a[i,j]   <- pow(prospects.a[i,4],gamma.gain[j]) + pow(prospects.a[i,2],gamma.gain[j])
      		z.y.a[i,j]   <- pow(prospects.a[i,4],gamma.loss[j]) + pow(prospects.a[i,2],gamma.loss[j]) 

      		Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}

   		for (i in 121:180)# Item-Loop, mixed gambles,gamble B
   		{
    			v.x.b[i,j] <- pow(prospects.b[i,3],alpha[j])       
    			v.y.b[i,j] <- (-1 * lambda[j]) * pow((-1 * prospects.b[i,1]),beta[j])       

     			w.x.b[i,j] <- pow(prospects.b[i,4],gamma.gain[j]) / pow(z.x.b[i,j],(1/gamma.gain[j])) 
      		w.y.b[i,j] <- pow(prospects.b[i,2],gamma.loss[j]) / pow(z.y.b[i,j],(1/gamma.loss[j])) 
      		z.x.b[i,j]   <- pow(prospects.b[i,4],gamma.gain[j]) + pow(prospects.b[i,2],gamma.gain[j])
      		z.y.b[i,j]   <- pow(prospects.b[i,4],gamma.loss[j]) + pow(prospects.b[i,2],gamma.loss[j]) 

    			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 121:180)# Item-Loop, mixed gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*sens[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


 
 	}   
}