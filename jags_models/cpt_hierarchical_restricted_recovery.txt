# Fits Cumulative Prospect Theory
# Data from Rieskamp (30 paritipants, 60 gamble-pairs 
# with positive outcomes, 60 gamble-pairs with negative
# outcomes, and 60 gamble-pairs with mixed outcomes)


model
{


# The model assumes that every participant has a unique parameter-value 
# on each of the six parameters of hierarchical-CPT (see, Nilsson, Rieskamp, & Wagnemakers, 2010).
# Furthermore, it assumes that the individual values on parameter-dimension X 
# are sampled from the hyperdistribution for X. This has to be defined in the model code.

	
	for (j in 1:cur_n)
	{

		# We start by defining that participant j has a unique parameter-value 
		# on each of the six parameters: alpha, alpha, gamma, delta, lambda, and luce 
		# (the choice-rule parameter).

		alpha[j] <- phi(alpha.phi[j])
		gamma[j] <- phi(gamma.phi[j])
		delta[j] <- phi(delta.phi[j])	
		luce[j]   <- exp(lluce[j]) 
            	lambda[j] <- exp(llambda[j])
		
		# We put group-level normal?s on the individual parameters:

		alpha.phi[j] ~ dnorm(mu.phi.alpha,tau.phi.alpha)T(-3, 3)
		gamma.phi[j] ~ dnorm(mu.phi.gamma,tau.phi.gamma)T(-3, 3)
		delta.phi[j] ~ dnorm(mu.phi.delta,tau.phi.delta)T(-3, 3)
            	lluce[j]   ~ dnorm(lmu.luce, ltau.luce)
            	llambda[j] ~ dnorm(lmu.lambda, ltau.lambda)


		
	}


	# Here priors for the hyperdistributions are defined:
	mu.phi.alpha ~ dnorm(0,1)
	tau.phi.alpha <- pow(sigma.phi.alpha,-2)
	sigma.phi.alpha ~ dunif(0,10)


	mu.phi.gamma ~ dnorm(0,1)
	tau.phi.gamma <- pow(sigma.phi.gamma,-2)
	sigma.phi.gamma ~ dunif(0,10)

	mu.phi.delta ~ dnorm(0,1)
	tau.phi.delta <- pow(sigma.phi.delta,-2)
	sigma.phi.delta ~ dunif(0,10)
	
	lmu.lambda    ~ dunif(-2.3, 1.61) 
      	ltau.lambda  <- pow(lsigma.lambda,-2)
      	lsigma.lambda ~ dunif(0,1.13)    

      	lmu.luce    ~ dunif(-2.3, 1.61)   
      	ltau.luce  <- pow(lsigma.luce,-2)
      	lsigma.luce ~ dunif(0,1.13)       

	
	# To obtain the mean of the hyper distribution on the wanted scale:
	mu.alpha <- phi(mu.phi.alpha) 
	mu.gamma <- phi(mu.phi.gamma) 
	mu.delta <- phi(mu.phi.delta) 
	mu.lambda <- exp(lmu.lambda)
	mu.luce   <- exp(lmu.luce)
	
	mu.alpha_sebi <-  phi(mu.phi.alpha / sqrt(1+ pow(sigma.phi.alpha, 2))) 
	mu.gamma_sebi <- phi(mu.phi.gamma / sqrt(1+ pow(sigma.phi.gamma, 2)))
  mu.delta_sebi <- phi(mu.phi.delta / sqrt(1+ pow(sigma.phi.delta, 2))) 
  mu.luce_sebi   <- exp(lmu.luce + pow(lsigma.luce, 2)/2)
  mu.lambda_sebi   <- exp(lmu.lambda + pow(lsigma.lambda, 2)/2)
  


# It is now time to define how the model should be fit to data. 

	for (j in 1:cur_n)# Subject-loop
	{
			for (i in 1:60)# Item-Loop, mixed gambles,gamble A
   		{
     			v.x.a[i,j] <- pow(mixed_prospects.a[i,3],alpha[j])       
      			v.y.a[i,j] <- (-1 * lambda[j]) * pow((-1 * mixed_prospects.a[i,1]),alpha[j])       

     			w.x.a[i,j] <- pow(mixed_prospects.a[i,4],gamma[j]) / pow(z.a[i,j],(1/gamma[j])) 
      			w.y.a[i,j] <- pow(mixed_prospects.a[i,2],delta[j]) / pow(z.a[i,j],(1/delta[j])) 
      			z.a[i,j]   <- pow(mixed_prospects.a[i,4],gamma[j]) + pow(mixed_prospects.a[i,2],delta[j]) 

      			Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}

   		for (i in 1:60)# Item-Loop, mixed gambles,gamble B
   		{
      			v.x.b[i,j] <- pow(mixed_prospects.b[i,3],alpha[j])       
      			v.y.b[i,j] <- (-1 * lambda[j]) * pow((-1 * mixed_prospects.b[i,1]),alpha[j])       

      			w.x.b[i,j] <- pow(mixed_prospects.b[i,4],gamma[j]) / pow(z.b[i,j],(1/gamma[j])) 
      			w.y.b[i,j] <- pow(mixed_prospects.b[i,2],delta[j]) / pow(z.b[i,j],(1/delta[j])) 
      			z.b[i,j]   <- pow(mixed_prospects.b[i,4],gamma[j]) + pow(mixed_prospects.b[i,2],delta[j]) 

      			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 1:60)# Item-Loop, mixed gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*luce[j])*(Vf.b[i,j]-Vf.a[i,j])))
			Data[i,j] ~ dbern(binval[i,j])
   		}
 	}   
}