# Fits Cumulative Prospect Theory
# Data from Rieskamp (30 paritipants, 60 gamble-pairs 
# with positive outcomes, 60 gamble-pairs with negative
# outcomes, and 60 gamble-pairs with mixed outcomes)
data
{
  ### Generate II as the identity matrix and zeros as a vector of zeros
  for (l in 1:5) {
    zeros[l] <- 0
   for (ll in 1:5) {
    II[l,ll] <- ifelse(l==ll, 1,0)
   }
  }
  

}

model
{


# The model assumes that every participant has a unique parameter-value 
# on each of the six parameters of hierarchical-CPT (see, Nilsson, Rieskamp, & Wagnemakers, 2010).
# Furthermore, it assumes that the individual values on parameter-dimension X 
# are sampled from the hyperdistribution for X. This has to be defined in the model code.

  
  #### Population distribution priors
  for (k in 1:5) {
    mu.trans.pars[k] ~ dnorm(0,1)
  }
  InvSig.trans.pars  ~ dwish(II[1:5,1:5],6)
  
  ####
  Sig.trans.pars[1:5,1:5] <- inverse(InvSig.trans.pars[1:5,1:5])  
  
  
  # Define the correct and incorrect actual parameter means
  mu.alpha <- 2*phi(mu.trans.pars[1]) 
  mu.gamma <- 2*phi(mu.trans.pars[2]) 
  mu.delta <- 2*phi(mu.trans.pars[3]) 
  mu.lambda<-   exp(mu.trans.pars[4])
  mu.luce  <-   exp(mu.trans.pars[5])
  
  mu.alpha_sebi <- 2*phi(mu.trans.pars[1] / sqrt(1+ pow(Sig.trans.pars[1,1], 2))) 
  mu.gamma_sebi <- 2*phi(mu.trans.pars[2] / sqrt(1+ pow(Sig.trans.pars[2,2], 2)))
  mu.delta_sebi <- 2*phi(mu.trans.pars[3] / sqrt(1+ pow(Sig.trans.pars[3,3], 2))) 
  mu.luce_sebi  <-   exp(mu.trans.pars[4] + pow(Sig.trans.pars[4,4], 2)/2)
  mu.lambda_sebi<-   exp(mu.trans.pars[5] + pow(Sig.trans.pars[5,5], 2)/2)
  
  
  
  
  
	## Participant distributions
	for (j in 1:30)
	{
    ## Sample random effects of participants from multi-variate normal
	  randeff[j,1:5]  ~ dmnorm(zeros, InvSig.trans.pars)
	  ## Compute transformed participant-parameters
	  sbj.trans.pars[j, 1:5] <- mu.trans.pars + randeff[j, 1:5]
	  
	  # Transform individual parameters to parameter-scale
	  alpha[j] <- 2*phi(sbj.trans.pars[j, 1])
		gamma[j] <- 2*phi(sbj.trans.pars[j, 2])
		delta[j] <- 2*phi(sbj.trans.pars[j, 3])
		luce[j]  <-   exp(sbj.trans.pars[j, 4]) 
    lambda[j] <-  exp(sbj.trans.pars[j, 5])
    
    ## Choice-loops:
    
    
   		for (i in 1:60)# Item-Loop, positive gambles,gamble A
   		{

    # j:s subjective value of outcome 1 in gamble A of gamble-pair i, v.x.a[i,j], equals:

     			v.x.a[i,j] <- pow(prospects.a[i,1],alpha[j])

    # where prospects.a[i,1] = outcome 1 and alpha[j] = j:s value on the alpha parameter
    # j:s subjective value of outcome 2 in gamble A
       
      			v.y.a[i,j] <- pow(prospects.a[i,3],alpha[j])       

# j:s subjective probability of the relatively more positive outcomes w.y.a[i,j]

     			
      			w.y.a[i,j] <- pow(prospects.a[i,4],gamma[j]) / pow(z.a[i,j],(1/gamma[j])) 
      			z.a[i,j]   <- pow(prospects.a[i,2],gamma[j]) + pow(prospects.a[i,4],gamma[j]) 

# j:s subjective value of gamble A in gamble-pair i

      			Vf.a[i,j]  <- (1 - w.y.a[i,j]) * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}


   		for (i in 1:60)# Item-Loop, positive gambles,gamble B
   		{
      			v.x.b[i,j] <- pow(prospects.b[i,1],alpha[j])       
      			v.y.b[i,j] <- pow(prospects.b[i,3],alpha[j])       

      			 
      			w.y.b[i,j] <- pow(prospects.b[i,4],gamma[j]) / pow(z.b[i,j],(1/gamma[j])) 
      			z.b[i,j]   <- pow(prospects.b[i,2],gamma[j]) + pow(prospects.b[i,4],gamma[j]) 

      			Vf.b[i,j]  <- (1 - w.y.b[i,j]) * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 1:60)# Item-Loop, positive gambles,choice-rule
   		{

# It is defined that j:s choice for gamble-pair i is sampled from a Bernoulli-distribution 
# with p = binval[i,j].
# The exponential choice-rule is used to compute binval[i,j] 
# (in this case: binval[i,j] = probability of B-choice).
      
			binval[i,j] <- (1)/(1+exp((-1*luce[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


		
   		for (i in 61:120)# Item-Loop, negative gambles,gamble A
   		{
     			v.x.a[i,j] <- (-1) * pow((-1 * prospects.a[i,1]),alpha[j])       
      			v.y.a[i,j] <- (-1) * pow((-1 * prospects.a[i,3]),alpha[j])       

     			w.x.a[i,j] <- pow(prospects.a[i,2],delta[j]) / pow(z.a[i,j],(1/delta[j])) 
     
      			z.a[i,j]   <- pow(prospects.a[i,2],delta[j]) + pow(prospects.a[i,4],delta[j]) 

      			Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + (1 - w.x.a[i,j]) * v.y.a[i,j]
      
   		}

   		for (i in 61:120)# Item-Loop, negative gambles,gamble B
   		{
      			v.x.b[i,j] <- (-1) * pow((-1 * prospects.b[i,1]),alpha[j])       
      			v.y.b[i,j] <- (-1) * pow((-1 * prospects.b[i,3]),alpha[j])       

      			w.x.b[i,j] <- pow(prospects.b[i,2],delta[j]) / pow(z.b[i,j],(1/delta[j])) 
      			
      			z.b[i,j]   <- pow(prospects.b[i,2],delta[j]) + pow(prospects.b[i,4],delta[j]) 

      			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + (1 - w.x.b[i,j]) * v.y.b[i,j]
      
   		}
 
   		for (i in 61:120)# Item-Loop, negative gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*luce[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


		for (i in 121:180)# Item-Loop, mixed gambles,gamble A
   		{
     			v.x.a[i,j] <- pow(prospects.a[i,3],alpha[j])       
      			v.y.a[i,j] <- (-1 * lambda[j]) * pow((-1 * prospects.a[i,1]),alpha[j])       

     			w.x.a[i,j] <- pow(prospects.a[i,4],gamma[j]) / pow(z.a[i,j],(1/gamma[j])) 
      			w.y.a[i,j] <- pow(prospects.a[i,2],delta[j]) / pow(z.a[i,j],(1/delta[j])) 
      			z.a[i,j]   <- pow(prospects.a[i,4],gamma[j]) + pow(prospects.a[i,2],delta[j]) 

      			Vf.a[i,j]  <- w.x.a[i,j] * v.x.a[i,j] + w.y.a[i,j] * v.y.a[i,j]
      
   		}

   		for (i in 121:180)# Item-Loop, mixed gambles,gamble B
   		{
      			v.x.b[i,j] <- pow(prospects.b[i,3],alpha[j])       
      			v.y.b[i,j] <- (-1 * lambda[j]) * pow((-1 * prospects.b[i,1]),alpha[j])       

      			w.x.b[i,j] <- pow(prospects.b[i,4],gamma[j]) / pow(z.b[i,j],(1/gamma[j])) 
      			w.y.b[i,j] <- pow(prospects.b[i,2],delta[j]) / pow(z.b[i,j],(1/delta[j])) 
      			z.b[i,j]   <- pow(prospects.b[i,4],gamma[j]) + pow(prospects.b[i,2],delta[j]) 

      			Vf.b[i,j]  <- w.x.b[i,j] * v.x.b[i,j] + w.y.b[i,j] * v.y.b[i,j]
      
   		}
 
   		for (i in 121:180)# Item-Loop, mixed gambles,choice-rule
   		{
      
			binval[i,j] <- (1)/(1+exp((-1*luce[j])*(Vf.b[i,j]-Vf.a[i,j])))
			rawdata[i,j] ~ dbern(binval[i,j])
   		}


 
 	}   
}